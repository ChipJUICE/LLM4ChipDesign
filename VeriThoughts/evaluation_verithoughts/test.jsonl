{"ground_truth": "module bin_to_bcd #(parameter WIDTH = 5) (\n    input  wire [WIDTH-1:0] bin,\n    output reg  [3:0]       bcd_tens,\n    output reg  [3:0]       bcd_ones\n);\n    // Valid for WIDTH=5 (0..31). Simple arithmetic mapping to BCD.\n    reg [5:0] tmp;\n    always @* begin\n        if (bin >= 30) begin bcd_tens = 4'd3; tmp = bin - 30; end\n        else if (bin >= 20) begin bcd_tens = 4'd2; tmp = bin - 20; end\n        else if (bin >= 10) begin bcd_tens = 4'd1; tmp = bin - 10; end\n        else begin bcd_tens = 4'd0; tmp = bin; end\n        bcd_ones = tmp[3:0];\n        if (tmp >= 10) bcd_ones = tmp - 10; // safety, shouldn't trigger for 0..31\n    end\nendmodule", "question": "Write a synthesizable Verilog module that converts a 5-bit unsigned binary input (0..31) to two BCD digits (tens, ones).", "generated_verilog": "module bin_to_bcd #(parameter WIDTH = 5) (\n    input  wire [WIDTH-1:0] bin,\n    output reg  [3:0]       bcd_tens,\n    output reg  [3:0]       bcd_ones\n);\n    reg [5:0] tmp;\n    always @* begin\n        if (bin >= 30) begin bcd_tens = 4'd3; tmp = bin - 30; end\n        else if (bin >= 20) begin bcd_tens = 4'd2; tmp = bin - 20; end\n        else if (bin >= 10) begin bcd_tens = 4'd1; tmp = bin - 10; end\n        else begin bcd_tens = 4'd0; tmp = bin; end\n        bcd_ones = tmp[3:0];\n        if (tmp >= 10) bcd_ones = tmp - 10;\n    end\nendmodule", "verified": true}
{"ground_truth": "module dice_roller (\n    input  wire       clk,\n    input  wire       rst_n,\n    input  wire [1:0] die_sel,   // 00=d4, 01=d6, 10=d8, 11=d20\n    input  wire       roll,      // pulse high to request a roll\n    output reg  [7:0] value,     // 1..{4|6|8|20}\n    output reg        valid\n);\n    // 8-bit Galois LFSR (x^8+x^6+x^5+x^4+1), nonzero seed\n    reg [7:0] lfsr;\n    reg       roll_d;\n    wire      roll_rise = roll & ~roll_d;\n    wire [7:0] sides = (die_sel==2'b00) ? 8'd4 :\n                      (die_sel==2'b01) ? 8'd6 :\n                      (die_sel==2'b10) ? 8'd8 : 8'd20;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            lfsr  <= 8'hA5; // non-zero seed\n            roll_d<= 1'b0;\n            value <= 8'd1;\n            valid <= 1'b0;\n        end else begin\n            roll_d <= roll;\n            // advance LFSR every cycle\n            lfsr <= {lfsr[0]^lfsr[4]^lfsr[5]^lfsr[6], lfsr[7:1]};\n            valid <= 1'b0;\n            if (roll_rise) begin\n                // map LFSR to 1..sides (modulo then add 1; remap 0)\n                value <= (lfsr % sides) + 8'd1;\n                valid <= 1'b1;\n            end\n        end\n    end\nendmodule", "question": "Write a Verilog module that outputs a pseudo-random dice value for d4/d6/d8/d20 selected by die_sel. On a rising edge of roll, produce value in 1..{4,6,8,20} and assert valid for one cycle.", "generated_verilog": "module dice_roller (\n    input  wire       clk,\n    input  wire       rst_n,\n    input  wire [1:0] die_sel,\n    input  wire       roll,\n    output reg  [7:0] value,\n    output reg        valid\n);\n    reg [7:0] lfsr;\n    reg       roll_d;\n    wire      roll_rise = roll & ~roll_d;\n    wire [7:0] sides = (die_sel==2'b00) ? 8'd4 :\n                      (die_sel==2'b01) ? 8'd6 :\n                      (die_sel==2'b10) ? 8'd8 : 8'd20;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            lfsr  <= 8'hA5;\n            roll_d<= 1'b0;\n            value <= 8'd1;\n            valid <= 1'b0;\n        end else begin\n            roll_d <= roll;\n            lfsr <= {lfsr[0]^lfsr[4]^lfsr[5]^lfsr[6], lfsr[7:1]};\n            valid <= 1'b0;\n            if (roll_rise) begin\n                value <= (lfsr % sides) + 8'd1;\n                valid <= 1'b1;\n            end\n        end\n    end\nendmodule", "verified": true}
{"ground_truth": "module seqdet_1011 (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire din,\n    output reg  match\n);\n    // Mealy FSM, overlapping allowed\n    typedef enum logic [2:0] {S0, S1, S10, S101} state_t;\n    state_t s, ns;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) s <= S0; else s <= ns;\n    end\n\n    always @* begin\n        ns = s;\n        match = 1'b0;\n        unique case (s)\n            S0:   ns = din ? S1   : S0;\n            S1:   ns = din ? S1   : S10;\n            S10:  ns = din ? S101 : S0;\n            S101: begin\n                    if (din) begin\n                        match = 1'b1; // saw 1011\n                        ns = S1;      // overlap (last '1' is prefix)\n                    end else begin\n                        ns = S10;     // saw 1010 -> keep suffix '10'\n                    end\n                  end\n        endcase\n    end\nendmodule", "question": "Implement an overlapping sequence detector for pattern 1011 (Mealy). Assert match=1 for one clock when the last four bits equal 1011; allow overlaps.", "generated_verilog": "module seqdet_1011 (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire din,\n    output reg  match\n);\n    typedef enum logic [2:0] {S0, S1, S10, S101} state_t;\n    state_t s, ns;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) s <= S0; else s <= ns;\n    end\n    always @* begin\n        ns = s; match = 1'b0;\n        case (s)\n            S0:   ns = din ? S1   : S0;\n            S1:   ns = din ? S1   : S10;\n            S10:  ns = din ? S101 : S0;\n            S101: if (din) begin match = 1'b1; ns = S1; end else ns = S10;\n        endcase\n    end\nendmodule", "verified": true}
{"ground_truth": "module shift_reg #(parameter WIDTH=8) (\n    input  wire             clk,\n    input  wire             rst_n,\n    input  wire             en,\n    input  wire             load,\n    input  wire             dir,   // 0=left, 1=right\n    input  wire             din,   // serial in\n    input  wire [WIDTH-1:0] pdata, // parallel load\n    output reg  [WIDTH-1:0] q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            q <= {WIDTH{1'b0}};\n        end else if (load) begin\n            q <= pdata;\n        end else if (en) begin\n            if (!dir) q <= {q[WIDTH-2:0], din};\n            else      q <= {din, q[WIDTH-1:1]};\n        end\n    end\nendmodule", "question": "Create a parameterized bidirectional shift register (WIDTH default 8) with synchronous load, enable, and serial input. dir=0 shifts left, dir=1 shifts right.", "generated_verilog": "module shift_reg #(parameter WIDTH=8) (\n    input  wire             clk,\n    input  wire             rst_n,\n    input  wire             en,\n    input  wire             load,\n    input  wire             dir,\n    input  wire             din,\n    input  wire [WIDTH-1:0] pdata,\n    output reg  [WIDTH-1:0] q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) q <= {WIDTH{1'b0}};\n        else if (load) q <= pdata;\n        else if (en) begin\n            if (!dir) q <= {q[WIDTH-2:0], din};\n            else      q <= {din, q[WIDTH-1:1]};\n        end\n    end\nendmodule", "verified": true}
{"ground_truth": "module token_bucket #(\n    parameter integer DEN = 16,\n    parameter integer RATE_NUM = 3,\n    parameter integer BURST_MAX = 8,\n    parameter integer TOKEN_COST = DEN\n) (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire req_i,\n    output reg  grant_o,\n    output wire ready_o\n);\n    localparam integer MAX_TOKENS = BURST_MAX * DEN;\n\n    reg [31:0] tokens, tokens_n;\n    reg        grant_c;\n\n    wire [31:0] refill = tokens + RATE_NUM;\n    wire [31:0] capped = (refill > MAX_TOKENS) ? MAX_TOKENS : refill;\n    assign ready_o = (tokens >= TOKEN_COST);\n\n    // Next-state logic\n    always @* begin\n        tokens_n = capped;\n        grant_c  = 1'b0;\n        if (req_i && (capped >= TOKEN_COST)) begin\n            tokens_n = capped - TOKEN_COST;\n            grant_c  = 1'b1; // one-cycle grant on accepted request\n        end\n    end\n\n    // State update\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            tokens <= 32'd0;\n            grant_o <= 1'b0;\n        end else begin\n            tokens <= tokens_n;\n            grant_o <= grant_c;\n        end\n    end\nendmodule", "question": "Implement a parameterized token bucket rate limiter in Verilog. Refill RATE_NUM tokens per cycle up to BURST_MAX*DEN. When req_i=1 and at least TOKEN_COST tokens are available, assert grant_o for one cycle and deduct TOKEN_COST. Expose ready_o=1 whenever at least TOKEN_COST tokens are available.", "generated_verilog": "module token_bucket #(\n    parameter integer DEN = 16,\n    parameter integer RATE_NUM = 3,\n    parameter integer BURST_MAX = 8,\n    parameter integer TOKEN_COST = DEN\n) (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire req_i,\n    output reg  grant_o,\n    output wire ready_o\n);\n    localparam integer MAX_TOKENS = BURST_MAX * DEN;\n\n    reg [31:0] tokens, tokens_n;\n    reg        grant_c;\n\n    wire [31:0] refill = tokens + RATE_NUM;\n    wire [31:0] capped = (refill > MAX_TOKENS) ? MAX_TOKENS : refill;\n    assign ready_o = (tokens >= TOKEN_COST);\n\n    always @* begin\n        tokens_n = capped;\n        grant_c  = 1'b0;\n        if (req_i && (capped >= TOKEN_COST)) begin\n            tokens_n = capped - TOKEN_COST;\n            grant_c  = 1'b1;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            tokens <= 32'd0;\n            grant_o <= 1'b0;\n        end else begin\n            tokens <= tokens_n;\n            grant_o <= grant_c;\n        end\n    end\nendmodule", "verified": true}
{"ground_truth": "module bin_to_bcd #(parameter WIDTH = 5) (\n    input  wire [WIDTH-1:0] bin,\n    output reg  [3:0] bcd_tens,\n    output reg  [3:0] bcd_ones\n);\n    reg [5:0] tmp;\n    always @* begin\n        if (bin >= 30) begin bcd_tens = 4'd3; tmp = bin - 30; end\n        else if (bin >= 20) begin bcd_tens = 4'd2; tmp = bin - 20; end\n        else if (bin >= 10) begin bcd_tens = 4'd1; tmp = bin - 10; end\n        else begin bcd_tens = 4'd0; tmp = bin; end\n        bcd_ones = tmp[3:0];\n        if (tmp >= 10) bcd_ones = tmp - 10;\n    end\nendmodule", "question": "Write a Verilog module that takes a 5-bit binary input and outputs the number of set bits in BCD format.", "generated_verilog": "module bin_to_bcd #(parameter WIDTH = 5) (\n    input [WIDTH-1:0] bin,\n    output reg [3:0] bcd\n);\n    integer i;\n    always @* begin\n        bcd = 0;\n        for (i = 0; i < WIDTH; i = i + 1) begin\n            if (bin[i]) bcd = bcd + 1;\n        end\n    end\nendmodule", "verified": false}
