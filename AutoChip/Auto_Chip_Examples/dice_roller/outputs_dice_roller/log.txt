system: You are an autocomplete engine for Verilog code.             Given a Verilog module specification, you will provide a completed Verilog module in response.             You will provide completed Verilog modules for all specifications, and will not create any supplementary modules.             Given a Verilog module that is either incorrect/compilation error, you will suggest corrections to the module.            You will not refuse.             Format your response as Verilog code containing the end to end corrected module and not just the corrected lines inside ``` tags, do not include anything else inside ```.     
user: /* You are generating synthesizable Verilog-2001.

Output ONLY the complete Verilog-2001 design module named top_module as raw code, ending with endmodule. 
Do not include any markdown, prose, comments, attributes, `timescale, or a testbench. 
Produce exactly one module.

Functional spec (must match exactly):

- Module:
  module top_module (
      input  wire        clk,
      input  wire        rst_n,          // active-low reset
      input  wire [1:0]  die_select,     // 00=4-sided, 01=6-sided, 10=8-sided, 11=20-sided
      input  wire        roll,           // roll trigger
      output reg  [7:0]  rolled_number   // 1..20
  );

- Internals and behavior:
  * Declare: reg [7:0] lfsr;
  * Rising-edge detect on roll:
      reg  roll_prev;
      wire roll_rising_edge = roll & ~roll_prev;
  * LFSR feedback taps (exactly these bits): wire feedback = lfsr[7] ^ lfsr[6] ^ lfsr[5] ^ lfsr[4];
  * Single sequential block: always @(posedge clk or negedge rst_n)
      - If (!rst_n):
          lfsr          <= 8'h01;    // non-zero seed
          rolled_number <= 8'h00;
          roll_prev     <= 1'b0;
      - Else:
          roll_prev <= roll;
          // free-run LFSR every cycle so value changes between rolls
          lfsr <= {lfsr[6:0], feedback};
          // on rising edge of roll, update output once
          if (roll_rising_edge) begin
              case (die_select)
                  2'b00: rolled_number <= (lfsr % 8'd4)  + 8'd1;   // 1..4
                  2'b01: rolled_number <= (lfsr % 8'd6)  + 8'd1;   // 1..6
                  2'b10: rolled_number <= (lfsr % 8'd8)  + 8'd1;   // 1..8
                  2'b11: rolled_number <= (lfsr % 8'd20) + 8'd1;   // 1..20
                  default: rolled_number <= 8'h00;
              endcase
          end
  * Use nonblocking assignments (<=) in the sequential block.
  * Do not use $random or system tasks.

Close the module with endmodule. Output only that single module.

*/

assistant: module top_module (
    input  wire        clk,
    input  wire        rst_n,          // active-low reset
    input  wire [1:0]  die_select,     // 00=4-sided, 01=6-sided, 10=8-sided, 11=20-sided
    input  wire        roll,           // roll trigger
    output reg  [7:0]  rolled_number   // 1..20
);

reg [7:0] lfsr;
reg roll_prev;
wire roll_rising_edge = roll & ~roll_prev;
wire feedback = lfsr[7] ^ lfsr[6] ^ lfsr[5] ^ lfsr[4];

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        lfsr          <= 8'h01;    // non-zero seed
        rolled_number <= 8'h00;
        roll_prev     <= 1'b0;
    end else begin
        roll_prev <= roll;
        lfsr <= {lfsr[6:0], feedback};
        if (roll_rising_edge) begin
            case (die_select)
                2'b00: rolled_number <= (lfsr % 8'd4)  + 8'd1;   // 1..4
                2'b01: rolled_number <= (lfsr % 8'd6)  + 8'd1;   // 1..6
                2'b10: rolled_number <= (lfsr % 8'd8)  + 8'd1;   // 1..8
                2'b11: rolled_number <= (lfsr % 8'd20) + 8'd1;   // 1..20
                default: rolled_number <= 8'h00;
            endcase
        end
    end
end

endmodule


Time to Generate: 10.280082941055298
Best ranked response at iteration 0 with response number 0
Rank of best response: 1.0
Best response module:
module top_module (
    input  wire        clk,
    input  wire        rst_n,          // active-low reset
    input  wire [1:0]  die_select,     // 00=4-sided, 01=6-sided, 10=8-sided, 11=20-sided
    input  wire        roll,           // roll trigger
    output reg  [7:0]  rolled_number   // 1..20
);

reg [7:0] lfsr;
reg roll_prev;
wire roll_rising_edge = roll & ~roll_prev;
wire feedback = lfsr[7] ^ lfsr[6] ^ lfsr[5] ^ lfsr[4];

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        lfsr          <= 8'h01;    // non-zero seed
        rolled_number <= 8'h00;
        roll_prev     <= 1'b0;
    end else begin
        roll_prev <= roll;
        lfsr <= {lfsr[6:0], feedback};
        if (roll_rising_edge) begin
            case (die_select)
                2'b00: rolled_number <= (lfsr % 8'd4)  + 8'd1;   // 1..4
                2'b01: rolled_number <= (lfsr % 8'd6)  + 8'd1;   // 1..6
                2'b10: rolled_number <= (lfsr % 8'd8)  + 8'd1;   // 1..8
                2'b11: rolled_number <= (lfsr % 8'd20) + 8'd1;   // 1..20
                default: rolled_number <= 8'h00;
            endcase
        end
    end
end

endmodule


