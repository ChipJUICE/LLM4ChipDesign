{'role': 'system', 'content': 'You are an autocomplete engine for Verilog code.             Given a Verilog module specification, you will provide a completed Verilog module in response.             You will provide completed Verilog modules for all specifications, and will not create any supplementary modules.             Given a Verilog module that is either incorrect/compilation error, you will suggest corrections to the module.            You will not refuse.             Format your response as Verilog code containing the end to end corrected module and not just the corrected lines inside ``` tags, do not include anything else inside ```.     '}
{'role': 'user', 'content': "/* You are generating synthesizable Verilog-2001.\n\nOutput ONLY the complete Verilog-2001 design module named top_module as raw code, ending with endmodule. \nDo not include any markdown, prose, comments, attributes, `timescale, or a testbench. \nProduce exactly one module.\n\nFunctional spec (must match exactly):\n\n- Module:\n  module top_module (\n      input  wire        clk,\n      input  wire        rst_n,          // active-low reset\n      input  wire [1:0]  die_select,     // 00=4-sided, 01=6-sided, 10=8-sided, 11=20-sided\n      input  wire        roll,           // roll trigger\n      output reg  [7:0]  rolled_number   // 1..20\n  );\n\n- Internals and behavior:\n  * Declare: reg [7:0] lfsr;\n  * Rising-edge detect on roll:\n      reg  roll_prev;\n      wire roll_rising_edge = roll & ~roll_prev;\n  * LFSR feedback taps (exactly these bits): wire feedback = lfsr[7] ^ lfsr[6] ^ lfsr[5] ^ lfsr[4];\n  * Single sequential block: always @(posedge clk or negedge rst_n)\n      - If (!rst_n):\n          lfsr          <= 8'h01;    // non-zero seed\n          rolled_number <= 8'h00;\n          roll_prev     <= 1'b0;\n      - Else:\n          roll_prev <= roll;\n          // free-run LFSR every cycle so value changes between rolls\n          lfsr <= {lfsr[6:0], feedback};\n          // on rising edge of roll, update output once\n          if (roll_rising_edge) begin\n              case (die_select)\n                  2'b00: rolled_number <= (lfsr % 8'd4)  + 8'd1;   // 1..4\n                  2'b01: rolled_number <= (lfsr % 8'd6)  + 8'd1;   // 1..6\n                  2'b10: rolled_number <= (lfsr % 8'd8)  + 8'd1;   // 1..8\n                  2'b11: rolled_number <= (lfsr % 8'd20) + 8'd1;   // 1..20\n                  default: rolled_number <= 8'h00;\n              endcase\n          end\n  * Use nonblocking assignments (<=) in the sequential block.\n  * Do not use $random or system tasks.\n\nClose the module with endmodule. Output only that single module.\n\n*/\n"}
{role : 'assistant', content : '```
module top_module (
    input  wire        clk,
    input  wire        rst_n,          // active-low reset
    input  wire [1:0]  die_select,     // 00=4-sided, 01=6-sided, 10=8-sided, 11=20-sided
    input  wire        roll,           // roll trigger
    output reg  [7:0]  rolled_number   // 1..20
);

    reg [7:0] lfsr;
    reg  roll_prev;
    wire roll_rising_edge = roll & ~roll_prev;
    wire feedback = lfsr[7] ^ lfsr[6] ^ lfsr[5] ^ lfsr[4];

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            lfsr          <= 8'h01;    // non-zero seed
            rolled_number <= 8'h00;
            roll_prev     <= 1'b0;
        end else begin
            roll_prev <= roll;
            // free-run LFSR every cycle so value changes between rolls
            lfsr <= {lfsr[6:0], feedback};
            // on rising edge of roll, update output once
            if (roll_rising_edge) begin
                case (die_select)
                    2'b00: rolled_number <= (lfsr % 8'd4)  + 8'd1;   // 1..4
                    2'b01: rolled_number <= (lfsr % 8'd6)  + 8'd1;   // 1..6
                    2'b10: rolled_number <= (lfsr % 8'd8)  + 8'd1;   // 1..8
                    2'b11: rolled_number <= (lfsr % 8'd20) + 8'd1;   // 1..20
                    default: rolled_number <= 8'h00;
                endcase
            end
        end
    end
endmodule
```'}

 Iteration rank: 1.0

 Model: gpt-4o-mini
 Input tokens: 691
 Output tokens: 443
Total cost: $0.0003694500
